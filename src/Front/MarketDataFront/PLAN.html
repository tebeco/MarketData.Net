<html><head><meta charset="UTF-8"></head><h1>Exercice 0 - vérifier l'installation</h1>
<p>Depuis votre IDE, lancer la classe Market puis la classe Application avant d'afficher la page <a href="http://localhost:8000">index.html</a> dans un navigateur.<br/>Il n'y aura pas encore grand chose d'intéressant à l'écran, il faudra attendre l'exercice 6 pour voir des données à l'écran...<br/>Vous n'aurez pas à modifier la structure des classes, la signature des méthodes. Les tests sont déjà écrits, il suffira de les activer au fil des exercices.</p>
<h1>Exercice 1 - transformation simple</h1>
<p>On commence avec du java dans le module marketdata-web.<br/> Le but est de rendre opérationnelle la classe <strong>ForexServer</strong> pour qu'elle propage les taux de change euro / dollar  sous forme de <strong>Double</strong> provenant du service ForexProvider. Il faut utiliser le client forexEventStreamClient comme ci-dessous:  <pre>
   protected Observable&lt;Double&gt; getEvents(HttpRequest request) {
     Observable&lt;String&gt; rawEvents = forexEventStreamClient.readServerSideEvents();
     ...
</pre>  Note: le paramètre <em>request</em> n'est pas utile pour cet exercice.<br/> La méthode <strong>Quote::fromJson</strong> pourra être utilisée pour parser les données brutes obtenues et créer des DTOs <strong>Quote</strong>.<br/> Test d'acceptance: Test 1 dans <strong>ForexServerTest</strong><br/> Opérateurs Rx: <strong>map &amp; doOnNext</strong> (éventuellement pour du debug)</p>
<h1>Exercice 2 - on ne prend que le premier !</h1>
<p>Toujours dans la classe <strong>ForexServer</strong>, il faut maintenant modifier le code pour qu'à chaque souscription on ne  renvoie qu'une seule valeur.<br/> Test d'acceptance: Test 2 dans <strong>ForexServerTest</strong><br/> Opérateurs Rx: <strong>take</strong> </p>
<h1>Exercice 3 - premier filtre</h1>
<p>Dans la classe <strong>StockQuoteServer</strong>, faire en sorte de prendre en compte le paramètre HTTP "STOCK" pour filtrer les  cotations et ne pas tout envoyer au navigateur.<br/> Test d'acceptance: Test 3 dans <strong>StockQuoteServerTest</strong><br/> Opérateurs Rx: <strong>filter</strong> </p>
<h1>Exercice 4 - premiers pas en Typescript</h1>
<p>Le code Typescript est localisé dans le module marketdata-web, dans les répertoires src/main/javascript et src/test/javascript. Pour lancer les tests, il suffit de se placer dans le module marketdata-web et de taper en ligne de commande <strong>npm test</strong>. Les tests à jouer sont désactivés avec le préfixe <strong>it.skip(...)</strong>. Pour activer un test, il suffit de supprimer le préfixe <strong>skip</strong> et d'écrire <strong>it(...)</strong></p>
<p>Dans le fichier <strong>Stock.ts</strong>, modifier la méthode <strong>parseRawStream</strong> pour parser les messages json venant du server et renvoyer un flux d'objects <strong>Quote</strong><br/>Test d'acceptance: Test 4 dans <strong>StockTest.ts</strong><br/>Opérateurs Rx: <strong>map</strong> </p>
<h1>Exercice 5 - ça monte et ça baisse</h1>
<p>Ici le but est de détecter quand le cours monte et quand il baisse. Dans le flux renvoyé par <strong>detectTrends</strong> il y aura un un événement "green" lorsque le cours augmente, un événement "red" lorsqu'il baisse. On va donc avoir besoin de comparer chaque cotation avec la cotation précédente. On va utiliser l'opérateur zip pour combiner 2 flux:</p>
<ol>
  <li>le flux de cotations tel quel</li>
  <li>le même flux de cotations mais décalé d'un événement grâce à l'opérateur skip</li>
</ol>
<p>Ainsi nous allons pouvoir comparer les cotations 2 à 2 et renvoyer un flux de résultats en sorti de l'opérateur zip.</p>
<p>Test d'acceptance: Test 5 et 6 dans <strong>StockTest.ts</strong><br/>Opérateurs Rx: <strong>skip et zip</strong> </p>
<h1>Exercice 6 - première combinaison avec flatmap</h1>
<p>Retour au code Java<br/>C'est bien de pouvoir filtrer, faut-il encore savoir ce que l'on a sous la main... L'idée de cet exercice est de récupérer les informations sur les stocks qui sont actives, celles pour lesquelles il y a eu au moins une cotation depuis la souscription.<br/>Dans la classe <strong>StockServer</strong>, pour chaque cotation, venant de <strong>quoteEventStreamClient.readServerSideEvents()</strong>, demander à partir du code de la cotation les infos sur la stock correspondante à l'aide de <strong>stockClient.request()</strong>.<br/><strong>Quote::fromJson</strong> et <strong>Stock::fromJson</strong> pourront être utilisées pour parser les données brutes et créer des DTOs.<br/>Test d'acceptance: Test 7 dans <strong>StockServerTest</strong><br/>Opérateurs Rx: <strong>map &amp; flatmap</strong> </p>
<p>À partir de maintenant, si vous relancez Market et Application, l'interface sur <a href="http://localhost:8000">index.html</a> va commencer à afficher quelque chose.</p>
<h1>Exercice 7 - pas de doublons</h1>
<p>On reprend l'exercice précédent et cette fois-ci on utilise l'opérateur distinct pour ne pas envoyer plusieurs fois les informations sur une même stock.<br/>Test d'acceptance: Test 8 dans <strong>StockServerTest</strong><br/>Opérateurs Rx: <strong>distinct &amp; map</strong></p>
<h1>Exercice 8 - on coupe au bout de 10 secondes</h1>
<p>Le code écrit jusqu'à maintenant fonctionne mais on a un souci: la connection HTTP utilisée pour récupérer les descriptions des stocks n'est jamais coupée. Pour s'en convaincre vous pouvez ouvrir et fermer plusieurs fois l'application <a href="http://localhost:8000">WEB</a> et regarder ce qui est loggé au niveau des process java.<br/>On va donc modifier la classe <strong>StockServer</strong> pour que le flux soit coupé au bout de 10 secondes.<br/>Attention il y a un piège, pour que le test passe il faut penser au scheduler...<br/>Test d'acceptance: Test 9 dans <strong>StockServerTest</strong><br/>Opérateurs Rx: <strong>takeUntil &amp; Observable.timer()</strong></p>
<h1>Exercice 9 - gestion d'état et calcul d'un prix vwap</h1>
<p>On va maintenant consommer un flux de transactions pour calculer pour un titre, le volume d'actions échangées  ainsi qu'un prix vwap, c'est à dire une moyenne pondérée du prix.<br/> En gros si 10 actions google ont été vendu à 7000$ puis 20 actions à 15200$, alors le prix vwap est égale à  (7000 + 15200) / (10 + 20) = 740$<br/>Comme on est gentil, ce petit calcul est déjà implémenté dans la classe <strong>VWap</strong>, il suffit d'utiliser la méthode <strong>Vwap::addTrade</strong>. Pour chaque événement <strong>Trade</strong> reçu, le serveur <strong>VwapServer</strong> va envoyer un événement correspondant à un nouveau prix <strong>VWap</strong>, calculé en fonction du prix <strong>Vwap</strong> précédent ainsi que du <strong>Trade</strong> reçu.<br/>Dans cet exercice, et c'est nouveau, il faut donc gérer un état, le prix Vwap. Pour cette raison on va utiliser l'opérateur scan. Attention il y a plusieurs variantes de cet opérateur, il faut utiliser celle qui propose de gérer un accumulateur...<br/>Test d'acceptance: Test 10 et Test 11 dans <strong>VwapServerTest</strong><br/>Opérateurs Rx: <strong>map, filter, skip &amp; scan</strong> </p>
<h1>Exercice 10 - échantillonage</h1>
<p>Dans la vraie vie, énormément de transactions sont réalisées sur les marchés. Pour éviter d'envoyer vers l'interface  web plus de prix vwap que nécessaire, nous allons maintenant utiliser l'opérateur Rx "sample" pour limiter le nombre de  messages envoyés sur le web. On veut envoyer vers le navigateur au maximum un message par seconde.<br/> Comme précédemment, pensez au scheduler pour les tests...<br/> Test d'acceptance: Test 12 dans <strong>VwapServerTest</strong><br/> Opérateurs Rx: <strong>sample</strong></p>
<h1>Exercice 11 - combinaison cotations / taux de changes</h1>
<p>Le but maintenant est de faire en sorte que les cotations transmises par la classe <strong>StockQuoteServer</strong> soient exprimées  en euros, et non en dollars.<br/> A chaque cotation du flux stockEventStreamClient.readServerSideEvents(), il faut appliquer un taux de change venant du  flux forexEventStreamClient.readServerSideEvents().<br/> A propos des taux de change, ici on reçois le taux euro/dollar qui peut être utilisé comme ci-dessous:  <pre>
 prix_usd = prix_eur * taux_eur_usd
 prix_eur = prix_usd / taux_eur_usd
</pre>  (ici on a en entré des prix en dollar, il faut donc faire une division)<br/> Attention, il ne faut pas générer plus de cotations sur une stock que ce que l'on a en entrée. En gros si le taux  de change fluctue alors que le cours de l'action en dollar ne varie pas, il ne faut pas générer d'événement.<br/> Test d'acceptance: Test 13 dans <strong>StockQuoteServerTest</strong><br/> Opérateurs Rx: <strong>map, take &amp; flatMap !!</strong> </p>
<h1>Exercice 12 - Cache "last value" sur le forex</h1>
<p>On va maintenant apporter une petite modification à la classe <strong>StockQuoteServerTest</strong>. Quand une cotation sur une stock arrive, on veut maintenant que le dernier cours de change euros/dollars connu soit utilisé. Cela veut dire que quand une cotation sur une stock en dollar arrive, pas besoin d'attendre de recevoir une nouvelle cotation EUR/USD, il suffit d'utiliser la dernière valeur connu. Pour pouvoir répondre à ce nouveau besoin il est fortement recommandé d'utiliser la classe <strong>BehaviorSubject</strong>.<br/>Test d'acceptance: Test 14 dans <strong>StockQuoteServerTest</strong></p>
<h1>Exercice 13 - Se désinscrire quand il faut...</h1>
<p>Vous avez peut-être un soucis avec le code écrit précédemment: vous continuez peut-être d'écouter le flux forex lorsque plus personne n'écoute le flux stock. L'idée ici est donc d'arrèter les souscriptions au flux forex quand s'arrètent les souscriptions au flux sur les stocks.<br/>Test d'acceptance: Test 15 dans <strong>StockQuoteServerTest</strong><br/>Opérateurs Rx: <strong>doOnUnsubscribe</strong></p>
<h1>Exercice 14 - Ne pas attendre indéfiniment</h1>
<p>Si jamais pour une raison ou un autre il y a un souci avec le flux forex, votre serveur va avoir un gros problème. Les cotations sur les stocks en dollars risquent de s'accumuler jusqu'à saturation de la mémoire de la JVM. Pour résoudre ce problème on va limiter le temps d'attente d'une cotation forex à 5 secondes, temps au dela duquel un événement d'erreur sera lancé.<br/>Test d'acceptance: Test 16 dans <strong>StockQuoteServerTest</strong><br/>Opérateurs Rx: <strong>timeout</strong></p>
<h1>Exercice 15 - min/max glissants</h1>
<p>Retour sur le code Typescript.<br/>On va maintenant implémenter les méthodes <strong>minFromPrevious</strong> et <strong>maxFromPrevious</strong> dans <strong>Stock.ts</strong>. L'idée est d'avoir un flux contenant la valeur minimum/maximum des n dernières cotations.<br/>Test d'acceptance: Tests 17, 18, 19 et 20 dans <strong>StockTest.ts</strong><br/>Opérateurs Rx: <strong>windowCount, flatMap, map, min &amp; max</strong> </p>
<h1>Exercice 16 - des souscriptions en double</h1>
<p>De nouveau sur du Java...<br/>Si vous ouvrez plusieurs fois l'application WEB dans plusieurs onglets de votre navigateur, vous allez constater que la charge sur les serveurs va augmenter de manière significative (vous allez vite entendre le ventilo de votre portable).<br/>Côté "market" les messages vont être envoyé en double et c'est dommage... Dans la classe <strong>Market</strong> justement, passez le flag <strong>flaky</strong> à true histoire de générer des erreurs lorsque plusieurs clients essayent de soucrire au même flux.<br/>En fait le problème vient de la classe <strong>MulticastEventStreamClient</strong> qui est censée générer des flux "chauds"...<br/>Test d'acceptance: Test 21 dans <strong>MulticastEventStreamClientTest</strong><br/>Opérateurs Rx: <strong>publish &amp; refcount</strong> </p>
<h1>Exercice 17 - réessayer en cas d'erreur</h1>
<p>Toujours dans la classe <strong>MulticastEventStreamClient</strong>, on va cette fois-ci mettre en place une politique de reconnection en cas d'erreur. Si jamais on reçoit un événement d'erreur, on attend 2 secondes puis on se reconnecte.<br/>Test d'acceptance: Test 22 dans <strong>MulticastEventStreamClientTest</strong><br/>Opérateurs Rx: <strong>retryWhen &amp; delay</strong> </p>
<h1>Bonus</h1>
<p>Reprendre l'exercice précédent et faire en sorte d'attendre 2, 4, 6 secondes puis abandonner</p></html>